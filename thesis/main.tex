\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage[export]{adjustbox}
\usepackage{float}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{hyperref}
\lstdefinestyle{mystyle}{    
    basicstyle=\footnotesize,
    numbers=left,
    stepnumber=1,
    showstringspaces=false,
    tabsize=1,
    breaklines=true,
    breakatwhitespace=false,
}

\usepackage[
backend=biber,
style=alphabetic,
sorting=ynt
]{biblatex}
\graphicspath{ {images/Final results/Architectures/Delays},{images/Final results/Architectures/Energy},{images/Final results/Architectures/Tasks}, {images} }
\usepackage{hyperref}
\usepackage{filecontents}
\title{\centerline{\includegraphics[width=8cm,height=8cm]{logo.png}}
{\scshape Dipartimento di Informatica}\\
\vspace{0.5cm}
Orchestration and collocation of application for autonomous drive}
\author{Candidato: Tommaso Lencioni\\
Relatori: Prof. Patrizio Dazzi, Prof. Antonio Brogi}
\date{Anno Accademico: 2020/2021}


\begin{document}
\maketitle


\tableofcontents{}

\chapter{Introduction to the problem}
\section{Application allocation}

\chapter{State of the art}
\section{Cloud Brokering}


\chapter{Metodologies}
\section{Application allocation}
\section{Tools}

\chapter{Thesis's goal}

\chapter{Pure Edge Sim}
\section{Features and limitations}
Pure Edge Sim (\textit{PES}) is a task oriented simulator. This trait is inherited from its parent tool (Cloud Sim).\\ Although this approach to simulations is suitable for testing task scheduling on Cloud and Edge, such decoupling represents a major barrier for the implementation of consequentials events involving more than one architecture layer.
An insight of the structure can be take in the paper proposed by the authors [LINK BIBLIOGRAFIA].

\section{Start a simulation}
Starting from main in MainApplication the method launchSimulation is called.\\
Configuration files are parsed.\\
Scenarios (combinations of parameters) are loaded into Iterations.
The iterations are executed one by one in a for loop.\\
Before starting the simulation the models are loaded:
\begin{itemize}
	\item The data centers are generated (this includes the edge devices).
	\item The tasks are generated at random for the devices that can generate them (every device have an APPLICATION\_LIST.
	\item An orchestrator is set.
	\item A network model is set.
\end{itemize}
The method startInternal of SimulationManager is called.\\
Before scheduling the task as stated below there is a check for the flag ENABLE\_ORCHESTRATORS. If it is false the task's orchestrator is the generating device itself.
All the task are scheduled to "this" (the Simulation Manager) with a delay based on the time established during their generation and with the tag SEND\_TO\_ORCH.\\
Tasks regarding the simulation (log printing, charts updating and progress bar) are scheduled.\\
All the classes that can receive a scheduled task (not necessary an edge device's task) implements the method processEvent that evaluate the tag of the event in a switch, trying to match it to a known case.

\section{Task's life}
Every step in a task's life is handled by either Simulation Manager or Network Model.
The initial scheduling to itself done for every task as stated in the previous section causes the Simulation Manager to catch the tasks in the method \textbf{process event}.\\
Due to the SEND\_TO\_ORCH flag set before the method \textbf{sendTaskToOrchestrator} is called.
Check if the task is failed.
If the orchestrators are enabled the closest device among the non-cloud orchestrators is set as such for the task.
Then the task is scheduled immediately with \textbf{scheduleNow} to the Network Model with tag SEND\_REQUEST\_FROM\_DEVICE\_TO\_ORCH.\\
\\
As stated before the Network Model of the simulation receive the task and in its processEvent method the right case is caught, calling the method \textbf{sendRequestFromDeviceToOrch} right away.\\
If the orchestrator of the task is the generating device itself 
the task is immediately scheduled to the Simulation Manager with SEND\_TASK\_FROM\_ORCH\_TO\_DESTINATION tag.
Otherwise a new transfer with
\begin{itemize}
	\item file size = the number of bits of the task's file
	\item type = REQUEST
\end{itemize}
is added to \textbf{transferProgressList} in order to simulate the request traveling through the network from the source to the orchestrator. Let's consider this case.\\

\subsection*{Network transfers}
The \textbf{transferProgressList} is an ArrayList initialized at the creation of the Network Model object.

It is loaded with transfers objects to simulate any kind of displacement of information.

In the method startInternal of Network Model an event with tag UPDATE\_PROGRESS is scheduled and repeated every NETWORK\_UPDATE\_INTERVAL as we can see in processEvent.

Here updateTasksProgress is called every update cycle.

In this method transferProgressList is scanned and, for every transfer in queue, the number of transfers on the same network (both WAN and LAN) and their utilization are evaluated.
\begin{itemize}
	\item WAN is used when the transfer involves the Cloud.
	\item LAN is used when two transfers share an endpoint.
\end{itemize}
Those exchanges undergo the bandwidth limit that is set to the minimum between LAN and WAN.
The bandwidth is updated (updateBandwidth) as well as the transfer (updateTransfer).\\
In this part a crucial role is played by the flag REALISTIC\_NETWORK\_MODEL. In fact, if true, the remaining file size of the transfer is set after a subtraction between the old remaining file size and the NETWORK\_UPDATE\_INTERVAL times the current bandwidth. This implies that a simulation done in this way reflects how the network delay is impacting the performance of the whole system.\\
This is essential to point out because if the flag is false the remaining file size is simply set to 0. Considering the fact that this happens every NETWORK\_UPDATE\_INTERVAL, if the latter is set to a low value the simulation could be not faithful.\\
Upon finishing the transfer (therefore the remaining file size is 0) \textbf{transferFinished} is called.
Here the network usage is updated and the transfer is removed from the queue.
According to the type of the transfer (request, task, container, result to orchestrator or result to device) a different "if guard" is satisfied and the corresponding method is called. After that call the energy model is always updated\\
In our case (REQUEST as type) the method offloadingRequestRecievedByOrchestrator is called.

Here there is a check for the type of task's orchestrator:
\begin{itemize}
	\item If it's Cloud then the task is scheduled to Simulation Manager with a delay of WAN\_PROPAGATION\_DELAY and tag SEND\_TASK\_FROM\_ORCH\_TO\_DESTINATION
	\item otherwise same as above except the immediate schedule (no WAN propagation delay if the orchestrator is an Edge Device).
\end{itemize}
\vspace{0.5cm}
In Simulation Manager the corresponding switch case is caught in processEvent and sendFromOrchToDestination is called.
Here there is a check if the task is failed. After that the a suitable VM is searched for the task.

\subsection*{VM Choice}
The method initialize of the Simulation Manager's orchestrator is called. The architecture of the simulation is evaluated and the respective method is called. Whatever method is called the only difference is the array of strings Architecture (containing the names of the supported architectures in this simulation) passed to the method nesting of assignTaskToVM and findVM.

The latter is up to implementation and utilizes the simulation algorithm to find the suitable VM.

[INSERIRE PERSONALIZZAZIONE DELL'ALGORITMO]

assignTaskToVM evaluates the VM (-1 results in a failure for lack of resources) and assign it to the task. 

%TODO fai capire che e' finita la sottosezione di VM Choice
\vspace{0.5cm}
There is a second evaluation for the VM=Null (this time in the Simulation Manager) then there is a check:
\begin{itemize}
	\item If the device that generated the task isn't the same that contains the assigned VM and the orchestrator of the task isn't the data center that contains the assigned VM then a task with tag SEND\_REQUEST\_FROM\_ORCH\_TO\_DESTINATION and destination the Network model is scheduled immediately.
	\item Otherwise the task is scheduled to this (Simulation Model) with tag EXECUTE\_TASK.
\end{itemize}
Let's consider the firts case.

In network model the corresponding case is caught and sendRequestFromOrchToDest is called.

A transfer is added to the queue with tag TASK. The transfer behavior is the same as mentioned in the Network transfer subsection. %TODO citalo.
Upon finishing the transfer the corresponding if is caught and executeTaskOrDownloadContainer is called.

Here there is a check for the ENABLE\_REGISTRY, in that case a new task with tag DOWNLOAD\_CONTAINER is scheduled.

Otherwise the task is scheduled to the Simulation Manager according to the type of data center of the VM assigned to the task (schedule with WAN\_PROPAGATION\_DELAY for Cloud and schedule immediately for the Edge) with the tag EXECUTE\_TASK.

In the simulation manager the corresponding branch is caught. There is a check for failure, then submitCloudlet is called on the broker (created at the initialization). The CPU utilization of the VM is increased accordingly and the energy model too.

The task is executed by the Cloud Sim part of the project.

At its termination (CLOUDLET\_RETURN case in processEvent of the DatacenterBrokerSimple class extension) the task is immediately scheduled to the simulation manager with tag TRANSFER\_RESULTS\_TO\_ORCH.

In Simulation Manager TRANSFER\_RESULTS\_TO\_ORCH case is taken. The CPU percentage is remove and the method sendResultsToOchestrator is called.

There is a check if the task is failed. Then:
\begin{itemize}
	\item If the source device isn't equal to the data center that contains the associated VM the task is scheduled immediately to the network model with tag SEND\_RESULT\_TO\_ORCH.
	\item otherwise the task is immediately scheduled to this (Simulation Manager) with the tag RESULT\_RETURN\_FINISHED.
\end{itemize}
Let's consider the first case.
In network model the corresponding case is caught and the method sendResultFromDevToOrch is called. Here there is a check:
\begin{itemize}
	\item if the orchestrator of the task isn't the device that generated the task then a file transfer is started with tag RESULTS\_TO\_ORCH
	\item otherwise the task is immediately scheduled to this (Network Model) with the tag SEND\_RESULT\_FROM\_ORCH\_TO\_DEV)
\end{itemize}
Let's consider the first case.

Upon finishing the transfer returnResultToDevice is called.
A check whether the orchestrator or the data center of the VM assigned to the task are Cloud. In that case the task with tag SEND\_RESULT\_FROM\_ORCH\_TO\_DEV is scheduled to this (Network Model) with WAN\_PROPAGATION\_DELAY.

Otherwise the same is done without delay.

The corresponding case is caught and the method sendResultFromOrchToDev is called. Here a new file transfer is added with tag RESULTS\_TO\_DEV.

Upon finishing the transfer the last else is caught and the method \mbox{resultsReturnedToDevice} is called. This schedules immediately the task for the Simulation Model with tag RESULT\_RETURN\_FINISHED.
\\
In Simulation Model the corresponding case i caught. A failure check is done, then a customizable method of the simulation orchestrator is called (resultsReturned) and the number of task is increased.
\end{document}
