\documentclass[12pt, a4paper]{report} %standard 12 punti, specifica anche la dimensione del documento
\usepackage[utf8]{inputenc} %specifica l'encoding
\usepackage{graphicx}
\usepackage{float}
\usepackage[section]{placeins}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }
%\counterwithin*{figure}{section} Posso resettare anche il contatore delle figure a ogni sezione
\counterwithin*{equation}{section} %Resetta il contatore delle equazioni a ogni sezione 
\counterwithin*{equation}{subsection}

\title{Report "Orchestratori"}
\author{Tommaso Lencioni}
%\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
%\maketitle
\section*{Osservazioni}
 \begin{itemize}
 	\item Dopo varie prove il fattore \textbf{cores} si e' rivelato molto importante in quanto, posizionando una stampa prima della terminazione della simulazione, ho avuto una misura dei task generati ma non eseguiti che, in assenza di indicazioni contrarie, vengono interpretati come task eseguiti con successo.\\
 	Questo avviene solamente con l'opzione wait\_for\_all\_tasks=false (se e' settato a true la simulazione non termina).\\
 	Estremizzando il numero di cores (come osservato anche nel report precedente) la quasi totalita' dei task risulta eseguita con successo.\\
 	Negli esempi gli autori mantengono il numero di cores richiesti a 1, continuero' su questa strada anche io.
 	\item Nel file \href{https://github.com/TommasoLencioni/PES/blob/4ccb63e670c42736d5d72610bd04af4832b2944a/simulations/Orchestratori/Orchestratori_Notion.pdf}{Orchestratori\_Notion.pdf} ho riassunto gli step della vita di un task con tutti i suoi passaggi tra le varie classi del simulatore.
 	\item In base al comportamento del metodo offloadingIsPossible della classe Orchestrator.java si ha una situazione chiara di come venga stabilita la possibilita' di offload:
 	\begin{itemize}
 		\item Su Cloud e' sempre possibile perche' si presume che tutti i dispositivi possano raggiungere il cloud.
 		\item Su Edge Datacenter e' subordinato alla sua distaza del dispositivo che genera il task (o, nel caso di orchestrazione attiva, dal suo orchestratore).
 		\item Su Mist (non piu' edge datacenter ma solo potenza di calcolo degli edge devices) e' permesso solo se il dispositivo che ha la VM che stiamo valutando non sia morto e sia in range (stavolta quello degli edge devices) del dispositivo che ha generato il task (o, nel caso di orchestrazione attiva, dal suo orchestratore).
 	\end{itemize}
 	\item Il concetto di Fog inteso come un avvicinamento del Cloud all'Edge non e' presente esplicitamente nel simulatore quindi lo escluderei dal "vocabolario" delle mie prove.
 	Dato che gli edge devices, qualora previsto, possano sempre fare offload su Cloud penso che si possa dare per scontata una vicinanza logica e fisica tipica del Fog Computing.\\
 	Discorso a se stante sono le RSU che sono veri e propri dispositivi (gli unici con questa funzione nei miei test) utilizzati come datacenter e individuati dal simulatore specificatamente come \textbf{EdgeDataCenters} e sfruttabili con architettura di calcolo Edge.
 	\item L'utilizzo degli orchestratori e' risultato non vantaggioso nelle mie prove in quanto introduce dell'overhead di comunicazione con il dispositivo che fa questa funzione (a meno che non sia esso stesso il generatore di tasks nel caso in cui gli orchestratori non siano abilitati).\\
	Questa degradazione di prestazione e' data dal vincolo stringente di 1 secondo di dealay massimo sull'applicazione dei sensori.\\
	Ho provato a monitorare la banda prima dell'assegnazione dell'orchestratore in modo da non assegnarlo qual'ora la rete non potesse garantire i requisiti di delay ma ho notato che l'utilizzo delle due reti e' sempre molto basso, non avrebbe senso fare una valutazione del genere.\\
	Riporto nella tabella seguente i risultati che ho ottenuto rendendo la RSU un orchestratore (modificando il file edge\_datacenter.xml) e simulando 150 devices.\\
	\\
 	\begin{tabular}{| c | c | c || c ||} %c center, l left, r right
		\hline
		Architettura & Orchestratore & Percentuale successo tasks\\ [1ex] 
		\hline
		\hline
		Cloud & Nessuno & 54\%\\
		\hline
		Cloud & Edge & 12.41 \%\\
		\hline
		Cloud & Cloud & 33.24\%\\
		\hline
		Edge & Nessuno & 54\%\\
		\hline
		Edge & Edge & 33.37\%\\
		\hline
		Edge & Cloud & 12.54\%\\
		\hline
\end{tabular}
	\\
	\\
	Ho provato anche a raddoppiare la potenza di calcolo dei datacenters (sia cloud che edge) ma il risultato non cambia.
	\\
	Allentando il requisito di delay massimo sull'applicativo dei sensori fino a 5s (valore che utilizzano anche gli autori come minimo delay) i risultati sono in linea con la precedente tabella, cioe' abbiamo un'alta percentuale di successo senza orchestratori (circa l'80\%) che si abbassa fino al 30\% in presenza di orchestratori.\\
Prima di passare alla manipolazione degli orchestratori vorrei stabilire una baseline in modo da poter avere dati per fare confronti tra le diverse strategie e la loro efficacia .

\end{itemize}
\section*{Dubbi}
\begin{itemize}
	\item Non ho capito il criterio con il quale viene utilizzato l'intero \textbf{phase}. (e.g. \textit{We also started with stage 2 and then stage 1, as this decreases the algorithm complexity})
\end{itemize}

\end{document}
